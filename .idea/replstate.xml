<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1417683249503">{:repl-history {:ide [], :local [&quot;(find [0 3] [0 3])&quot; &quot;(find [0 3] 0)&quot; &quot;(find [0 3] 1)&quot; &quot;(find  [[0 3]]  0)&quot; &quot;(get  [[0 3]]  0)&quot; &quot;(get  [[0 3]]  [0 3])&quot; &quot;(map #(Math/pow 2 (%1 %2)) 1 [1 2 3])&quot; &quot;(map #(Math/pow 2 (%1 %2)) [1] [1 2 3])&quot; &quot;Math/pow 2.17 (* (dimens-euq %1 %2) ) &quot; &quot;(map #(Math/pow 2 (+ %1 %2)) 1 [1 2 3])&quot; &quot;(map #(Math/pow 2 (+ %1 %2)) [1] [1 2 3])&quot; &quot;(map (fn [m v]\n     (+ m v)  ) [1] [1 2 3])&quot; &quot;(map (fn [m v]\n     (conj m (+ m v))   ) [1] [1 2 3])&quot; &quot;(map (fn [m v]\n     (conj (vec m) (+ m v))   ) [1] [1 2 3])&quot; &quot;(map (fn [m v]\n     (assoc m v)   ) [1] [1 2 3])&quot; &quot;(map (fn [m v]\n     (assoc [] m v)   ) [1] [1 2 3])&quot; &quot;(map (fn [m v]\n     (assoc {} m v)   ) [1] [1 2 3])&quot; &quot;(take-while empty? [-2 -1 0 1 2 3])&quot; &quot;(take-while nil? [-2 -1 0 1 2 3])&quot; &quot;(take-while (not nil?) [-2 -1 0 1 2 3])&quot; &quot;(defn dimens-euq [v1 v2]\n  (reduce + (map  #(Math/pow (- %1 %2) 2) v1 v2))\n  )&quot; &quot;(map #(Math/pow  (* (dimens-euq [[1 1]] %1) ) )   [[2 2]])&quot; &quot;(map #(Math/pow  (* (dimens-euq [1] %1) ) )   [2])&quot; &quot;(map #(Math/pow  (* (dimens-euq 1 %1) ) )   [2])&quot; &quot;(map #(Math/pow 2 (* (dimens-euq [[1 1]] %1) ) )   [[2 2]])&quot; &quot;(dimens-euq [1 1] [2 2])&quot; &quot;(map #(+ %1 5) [1 2 3 4 5])&quot; &quot;(map #(Math/pow 2 (* (dimens-euq [1 1] %1) ) )   [[2 2]])&quot; &quot;(map #(Math/pow 2 (* (dimens-euq [1 1] %1) ) )   [[2 2] [3 3]])&quot; &quot;(persistent! (fp-first.util.parse-file/parse-fl\n               \&quot;\\butterfly.txt\&quot;))&quot; &quot;(persistent! (fp-first.util.parse-file/parse-fl\n               \&quot;\\\\butterfly.txt\&quot;))&quot; &quot;(persistent! (fp-first.util.parse-file/parse-fl\n               \&quot;resources\\\\butterfly.txt\&quot;))&quot; &quot;(map-indexed assoc \&quot;foobar\&quot;)&quot; &quot;(map-indexed assoc {} \&quot;foobar\&quot;)&quot; &quot;(map-indexed (assoc {})  \&quot;foobar\&quot;)&quot; &quot;(map-indexed assoc   \&quot;foobar\&quot;)&quot; &quot;(map-indexed #(assoc {} %1 %2)   \&quot;foobar\&quot;)&quot; &quot;(def v transient [])&quot; &quot;(def v (transient []))&quot; &quot;(map-indexed #(assoc v %1 %2)   \&quot;foobar\&quot;)&quot; &quot;(map-indexed #(assoc! v %1 %2)   \&quot;foobar\&quot;)&quot; &quot;(def v (transient {}))&quot; &quot;(persistent! (map-indexed #(assoc! v %1 %2)   \&quot;foobar\&quot;))&quot; &quot;(first (map-indexed #(assoc! v %1 %2)   \&quot;foobar\&quot;))&quot; &quot;(defn-  cr-m [m k val]\n  (assoc m k val)\n  (inc k))&quot; &quot;(map-indexed {} points)&quot; &quot;(map-indexed #(assoc {} %1 %2) points)&quot; &quot;(reduce merge (map-indexed #(assoc {} %1 %2) points)) &quot; &quot;(reduce + [1 2 3 4 5 ])&quot; &quot;(potentials)&quot; &quot;(println potentials)&quot; &quot;(println points)&quot; &quot;(apply max (values potentials))&quot; &quot;(apply max (vals potentials))&quot; &quot;(apply max (keys potentials))&quot; &quot;(get potentials (apply max (keys potentials)))&quot; &quot;(get potentials first)&quot; &quot;(keys potentials)&quot; &quot;(key {a 1})&quot; &quot;(key {:a 1})&quot; &quot;(def m {a 1})&quot; &quot;(def m {1 4})&quot; &quot;(def m {:a 4})&quot; &quot;(key m)&quot; &quot;(key (a 2))&quot; &quot;(key [a 2])&quot; &quot;(key [:a 2])&quot; &quot;(key (find {a 2} a))&quot; &quot;(key (find {:a 2} :a))&quot; &quot;(merge {} (find {:a 2} :a))&quot; &quot;(get (merge {} (find {:a 2} :a)) :a)&quot; &quot;(map (get points %1) (1, 2, 3))&quot; &quot;(def points (into (sorted-map)  (map-indexed #(assoc {} %1 %2) (persistent!\n                                                                 (fp-first.util.parse-file/parse-fl\n                                                                   \&quot;resources\\\\butterfly.txt\&quot;)))))\n&quot; &quot;(map #(get fp-first.core/points %1) (1, 3, 4))&quot; &quot;points&quot; &quot;(get fp-first.core/points 1)&quot; &quot;(map #(get fp-first.core/points %1) (vec (1, 3, 4)))&quot; &quot;(find points (apply max (keys points)))&quot; &quot;(map #(get points %1) (vec (1, 3, 4)))&quot; &quot;fp-first.core/potentials&quot; &quot;(def potentials (into (sorted-map)\n                      (map-indexed #(assoc {} %2 %1)\n                                   (map #(fp-first.util.point/potential %1 (vals points))\n                                        (vals points)))))&quot; &quot;potentials&quot; &quot;(map (get points %1) (1, 3, 4))&quot; &quot;(map (get points %1) [1, 3, 4])&quot; &quot;(map #(get points %1) [1, 3, 4])&quot; &quot;(map #(get points %1) (1, 3, 4))&quot; &quot;(map #(get points %1) (vals {1 1, 2 2, 3 3}))&quot; &quot;(defn- re-count [cur-centr rmng-ptntls points]\n  (map assoc {} (map #(fp-first.util.point/rem-potential (key cur-centr)\n                                                         %1\n                                                         (get points (val cur-centr))\n                                                         (get points (get rmng-ptntls %1)))\n                     (keys rmng-ptntls))\n       (vals rmng-ptntls))\n  )&quot; &quot;(defn- re-count [cur-centr rmng-ptntls points]\n  (map  #(assoc {} %1 %2) (map #(fp-first.util.point/rem-potential (key cur-centr)\n                                                                   %1\n                                                                   (get points (val cur-centr))\n                                                                   (get points (get rmng-ptntls %1)))\n                               (keys rmng-ptntls))\n        (vals rmng-ptntls))\n  )&quot; &quot;(defn- re-count [cur-centr rmng-ptntls points]\n  (into (sorted-map) (map  #(assoc {} %1 %2) (map #(fp-first.util.point/rem-potential (key cur-centr)\n                                                                                      %1\n                                                                                      (get points (val cur-centr))\n                                                                                      (get points (get rmng-ptntls %1)))\n                                                  (keys rmng-ptntls))\n                           (vals rmng-ptntls)))\n\n  )&quot; &quot;(re-count (find {1.0 10} 1.0) {2.0 3, 4.0 5, 6.0 7} {3 [1,1], 5 [2,2], 7 [3,3]})&quot; &quot;(re-count (find {1.0 10} 1.0) {8.0 3, 4.0 5, 6.0 7} {3 [1,1], 5 [2,2], 7 [3,3]})&quot; &quot;(re-count (find {11.0 10} 1.0) {8.0 3, 4.0 5, 6.0 7} {3 [1,1], 5 [2,2], 7 [3,3]})&quot; &quot;(re-count (find {11.0 10} 11.0) {8.0 3, 4.0 5, 6.0 7} {3 [1,1], 5 [2,2], 7 [3,3]})&quot; &quot;(re-count (find {11.0 10} 11.0) {8.0 3, 4.0 5, 6.0 7} {3 [1,1], 5 [2,2], 7 [3,3], 10 [3,1]})&quot; &quot;(defn- dmin [cur-centr cntrs]\n  (apply min #(fp-first.util.point/dimens-euq (get points (val cur-centr)) %1) (map #(get points %1) (vals cntrs)))\n  )&quot; &quot;(apply min (9, 2, 3))&quot; &quot;(apply min [9, 2, 3])&quot; &quot;(map #(get points %1) [1, 2, 3])&quot; &quot;(into (vector) (map #(get points %1) [1, 2, 3]))&quot; &quot;(-main)&quot;], :remote []}}</component>
</project>

